#include <iostream>
#include <fstream>
#include <cstdlib>
#include <ctime>
#include <thread>
#include <mutex>

using namespace std;

const int ROOM_COUNT = 50;
int rooms[ROOM_COUNT] = {0};
mutex room_mutex;
int success_count = 0;

void saveToFile(const string& filename) {
    ofstream file(filename);
    for (int i = 0; i < ROOM_COUNT; ++i)
        file << rooms[i] << " ";
    file.close();
}

void bookRooms(int thread_id) {
    for (int i = 0; i < 25; ++i) {
        int room_id = rand() % ROOM_COUNT;

        lock_guard<mutex> lock(room_mutex);
        if (rooms[room_id] == 0) {
            rooms[room_id] = 1;
            cout << "Booked room: " << room_id << endl;
            success_count++;
        } else {
            cout << "Failed to book room: " << room_id << " (already taken)" << endl;
        }
    }
}

int main() {
    int proceed;
    cout << "Test Case 4: Parallel Booking (50 rooms via 4 threads)." << endl;
    cout << "Enter 1 to proceed: ";
    cin >> proceed;
    if (proceed != 1) {
        cout << "Aborted." << endl;
        return 0;
    }

    srand(42); // reproducible
    fill(rooms, rooms + ROOM_COUNT, 0); // ensure rooms are free

    thread t1(bookRooms, 1);
    thread t2(bookRooms, 2);
    thread t3(bookRooms, 3);
    thread t4(bookRooms, 4);

    t1.join();
    t2.join();
    t3.join();
    t4.join();

    cout << "Total bookings: " << success_count << "/100" << endl;
    cout << "Your Name" << endl;

    saveToFile("parallel_bookings.txt");
    return 0;
}